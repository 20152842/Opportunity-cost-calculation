## 1) 우선순위 원칙

### 우선순위(원칙)
1. **기능 정확성**: 계산 로직(총비용) 정의가 명확하고 재검산 가능해야 함  
2. **근거 제공**: 왜 그 결론인지(시간비용/직접비용 분해 + 수식) 보여줄 것  
3. **입력 검증 & 엣지 케이스**: 0/음수/단위 혼동/동일 결과 등 안전성 확보  
4. **사용성(UX)**: 프리셋 예시, 입력 최소화, 결과 가독성  

> **커밋 vs 문서화 원칙**
> - 커밋 메시지는 **“어떤 범위의 변경이 있었는지”를 짧게 요약**하는 데 집중한다.  
> - 반대로, **무엇을 왜 어떻게 바꿨는지(개선 과정/의사결정)**는  
>   - `CHANGELOG.md` (버전/날짜/요약/영향)  
>   - `AI_LOG.md` (AI 컨텍스트·검증·수정 과정)  
>   - `RETROSPECTIVE.md` (우선순위/시간 배분/회고)  
>   에 상세히 남겨 “개선 과정 기록”을 커밋 로그가 아니라 **문서 레벨에서 관리**한다.

### MVP 범위 고정(초기 계획)
- **반드시 포함**: 시급 입력, A/B 비교, Total Cost Index, 근거 표시(토글), 프리셋, 핵심 엣지 케이스
- **후순위/확장**: 다안 비교, 히스토리 저장, 피로/스트레스 옵션, 배포, 테스트

---

## 2) 시간 배분 계획 (초기 계획)

- 계산 로직/모델 정의 + 수식/소수점 기준: **25%**
- UI 구현(입력/결과/근거 토글/프리셋): **40%**
- 입력 검증 + 엣지 케이스 처리: **20%**
- 마감 정리(README/문서/배포/테스트 중 가능한 범위): **15%**

---

## 3) 최종 회고

### 실제 우선순위 조정
- 초기에는 “기능 정확성 → UX → 엣지 케이스 → 배포/문서” 순으로 생각했지만, 실제로는 **기능 정확성 + 엣지 케이스**를 한 번에 잡고, 그 위에 UX/문서를 얹는 흐름으로 조정했다.
- 프론트엔드 UI를 너무 일찍 다듬기보다, **계산 로직/검증/테스트**를 먼저 안정화시키고 이후 한 번에 스타일링을 정리했다.
- 다안 비교/히스토리/캐싱/배포 설정은 “MVP가 충분히 안정적이라는 확신”이 든 뒤에만 착수하도록 후순위로 두었다.

### 조정 이유
- 계산 로직과 엣지 케이스는 한 번 틀리면 이후 기능(다안 비교, 히스토리) 모두에 영향을 주기 때문에, 초기에 충분한 시간을 써서 수식/소수점 처리/동일 비용 케이스를 먼저 고정할 필요가 있었다.
- 프론트엔드에서 UX를 일찍 만지다 보니, API 스펙이 바뀔 때마다 화면 로직을 두 번씩 손보는 비효율이 보여서, “API/로직 먼저, UX는 후반 정리”로 전략을 바꾸었다.
- 시간 제약상 배포까지 실제로 끝내기보다는, **Docker/Heroku/Railway/AWS/GCP 가이드를 문서화**해서 “언제든 배포 가능한 상태”를 만드는 것이 더 현실적인 목표였다.

### 실제 시간 배분
- 로직: 35% (계산 모델, 서비스/DTO 설계, 다안 비교 로직, 캐싱)
- UI: 30% (기본 UI + 다안 비교/히스토리 UI, 반응형 디자인, UX 개선)
- 검증/엣지 케이스: 20% (입력 검증, 전역 예외 처리, 테스트 코드)
- 배포/테스트/문서: 15% (Docker/Procfile/프로필 설정, README/API/DEPLOYMENT/요약 문서)

### 다음에 개선할 점
- 히스토리를 localStorage가 아닌 서버/DB에 저장하고, 로그인/사용자 별 히스토리를 제공하면 “실제 서비스”로 한 단계 더 나아갈 수 있을 것 같다.
- 현재 캐시는 인메모리라 단일 인스턴스 기준이므로, Redis 등 분산 캐시를 도입해 수평 확장 환경에서도 일관된 성능을 보장하고 싶다.
- UX 측면에서는 “시간 가치에 대한 인사이트 메시지(예: 시급이 매우 높을 때)”를 더 풍부하게 제공해, 단순 계산기를 넘어 “의사결정 코치”에 가까운 경험으로 확장할 수 있다.
