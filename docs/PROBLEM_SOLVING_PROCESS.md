# 문제 해결 과정 (Problem-Solving Process)

## 목적
이 문서는 **문제를 어떻게 단계적으로 해결해 나갔는지**를 구체적으로 기록하여, 체계적인 접근 방식을 보여줍니다.

---

## 전체 프로세스 개요

```
[1단계] 문제 정의 & 범위 설정
   ↓
[2단계] MVP 설계 & 핵심 로직 구현
   ↓
[3단계] 안정성 확보 (검증 + 테스트)
   ↓
[4단계] 확장 기능 추가
   ↓
[5단계] 사용자 테스트 & 피드백 반영
   ↓
[6단계] 품질 강화 & 문서화
```

---

## 1단계: 문제 정의 & 범위 설정 (Day 1, 1시간)

### 해결하려는 문제
"사람들은 시간의 가치를 과소평가한다. 1,000원을 아끼려고 30분을 쓰는 비합리적 선택이 발생한다."

### 문제 분석
1. **근본 원인**: 시간을 돈으로 환산하는 명확한 기준이 없음
2. **증상**: 의사결정 피로, 사후 후회
3. **해결 방향**: 시급 기반 계산으로 객관적 지표 제공

### 범위 설정 프로세스

#### Step 1-1: 브레인스토밍 (할 수 있는 모든 것)
```
가능한 기능 목록:
□ 시급 입력 → 총비용 계산
□ 2개 선택지 비교
□ 3개 이상 선택지 비교
□ 히스토리 저장
□ 통계/인사이트
□ 소셜 공유
□ 로그인/사용자 관리
□ 모바일 앱
□ 피로도/스트레스 점수
□ AI 추천
```

#### Step 1-2: MoSCoW 분류
```
[Must Have - 반드시 필요]
✅ 시급 입력
✅ 2개 선택지 비교 (A/B)
✅ 총비용 계산 (직접비용 + 시간비용)
✅ 추천 결과 + 근거
✅ 입력 검증 (음수, 0 등)

[Should Have - 있으면 좋음]
✅ 다안 비교 (3~5개)
✅ 프리셋 예시
✅ 계산식 상세 표시
✅ 히스토리

[Could Have - 시간 있으면]
⚠️ 배포
⚠️ 캐싱
⚠️ 테스트 코드

[Won't Have - 하지 않음]
❌ 로그인
❌ AI 추천
❌ 통계
```

#### Step 1-3: MVP 확정
**최종 결정**: Must Have만 먼저 완성 → 동작 확인 → Should Have 추가

**이유**: 
- 핵심 가치(시급 기반 비교)를 먼저 검증
- 계산 로직이 틀리면 모든 기능이 무의미
- 확장 가능한 구조로 설계하면 나중에 추가 쉬움

---

## 2단계: MVP 설계 & 핵심 로직 구현 (Day 1, 4시간)

### 문제 분해

```
[큰 문제] 시급 기반 선택지 비교 계산기
    ↓
[작은 문제 1] 총비용을 어떻게 정의할 것인가?
[작은 문제 2] 입력은 무엇을 받을 것인가?
[작은 문제 3] 출력은 무엇을 보여줄 것인가?
[작은 문제 4] 프론트와 백엔드를 어떻게 분리할 것인가?
```

### Step 2-1: 계산 로직 정의

**문제**: "총비용"을 어떻게 정의할 것인가?

**해결 과정**:
1. **가설 1**: 총비용 = 직접비용 + 시간비용
2. **가설 2**: 시간비용 = (시급 ÷ 60) × 소요시간(분)
3. **검증**: 
   ```
   예시: 시급 15,000원, 10분, 3,000원
   → 시간비용 = 15,000 ÷ 60 × 10 = 2,500원
   → 총비용 = 3,000 + 2,500 = 5,500원
   
   ✅ 직관적으로 맞음
   ```
4. **수식 확정**: `TC = C + (W/60 × T)`

**의사결정 지점**:
- Q: 소수점은 어떻게 처리?
- A: `Math.floor()` 선택 → 이유: 돈은 버림이 일반적, 과대평가 방지

### Step 2-2: 데이터 구조 설계

**문제**: API 요청/응답 구조는?

**1차 설계**:
```java
// 너무 단순 → 확장성 없음
class Request {
    long wage;
    int timeA, timeB;
    long costA, costB;
}
```

**2차 설계 (개선)**:
```java
// DTO 분리 → 확장 가능
class CalculationRequest {
    Long hourlyWage;
    ComparisonOption optionA;
    ComparisonOption optionB;
}

class ComparisonOption {
    Integer timeMinutes;
    Long directCost;
}
```

**이유**: 나중에 `optionC`, `optionD` 추가 시 구조 변경 불필요

### Step 2-3: 레이어 분리

**문제**: Spring Boot 구조를 어떻게 나눌 것인가?

**해결**:
```
Controller (API 엔드포인트)
   ↓ CalculationRequest
Service (계산 로직)
   ↓ CalculationResponse
Model/DTO (데이터 구조)
```

**의사결정**:
- Repository 계층 없음 → 이유: DB 저장 불필요
- Cache는 Service 내부 → 이유: 로직과 캐싱을 함께 관리

### Step 2-4: 구현 순서

```
1. DTO 정의 (Request, Response, Option)
2. Service 계산 로직 (floor 포함)
3. Controller API 엔드포인트
4. 단위 테스트 (기본 케이스 5개)
5. Thymeleaf 템플릿 (입력 폼)
6. JavaScript (API 호출 + 결과 표시)
```

**이유**: 
- 백엔드 먼저 → API 스펙 고정
- 프론트엔드 나중 → API 변경 시 재작업 최소화

---

## 3단계: 안정성 확보 (Day 1~2, 3시간)

### 문제: "잘못된 입력을 어떻게 막을 것인가?"

### Step 3-1: 엣지 케이스 정의

**브레인스토밍**:
```
사용자가 뭘 잘못 입력할 수 있을까?
□ 시급 0원
□ 시급 음수
□ 시급 매우 큼 (100억원?)
□ 시간 음수
□ 시간 0분
□ 비용 음수
□ 비용 0원
□ null 입력
□ 문자 입력
□ 잘못된 JSON
```

### Step 3-2: 우선순위 분류

```
[P0 - 즉시 수정]
- null 입력 → @NotNull
- 음수 값 → @Min(0) 또는 @Min(1)
- 잘못된 JSON → GlobalExceptionHandler

[P1 - 허용하되 처리]
- 시간 0분 → 허용 (시간비용 0)
- 비용 0원 → 허용 (무료 옵션)
- 총비용 동일 → "동일" 표시

[P2 - 경고만]
- 시급 매우 큼 → confirm() 팝업
- 소요시간 매우 김 → (허용)
```

### Step 3-3: 검증 전략

**프론트엔드 검증** (UX):
```javascript
if (!hourlyWage || hourlyWage < 1) {
    showError('시급은 1원 이상이어야 합니다.');
    return false;
}
```

**백엔드 검증** (안전성):
```java
@Min(value = 1, message = "시급은 1원 이상이어야 합니다.")
private Long hourlyWage;
```

**이유**: 이중 검증으로 안정성 최대화

### Step 3-4: 테스트 케이스 작성

**초기 11개**:
1. 정상 계산 (A < B)
2. 정상 계산 (B < A)
3. 동일 총비용
4. 0분/0원 케이스
5. floor 처리
6. null 시급
7. 시급 0원
8. null 선택지
9. 잘못된 JSON
10. 빈 요청 본문
11. 음수 값

**확장 18개** (나중에 추가):
- 매우 큰 시급
- 매우 긴 시간
- 캐시 동작
- 음수 시간/비용 (분리)
- 시급 상한선 초과

---

## 4단계: 확장 기능 추가 (Day 2, 2시간)

### 문제: "2개만 비교하면 충분한가?"

### Step 4-1: 사용 시나리오 분석

**실제 사례**:
```
"마트를 3곳 비교하고 싶은데?"
→ 가까운 마트, 먼 마트, 대형마트, 편의점, 온라인

"출퇴근 방법을 비교하고 싶은데?"
→ 지하철, 버스, 자가용, 택시, 자전거
```

**결론**: 3~5개 비교가 실제 니즈

### Step 4-2: 다안 비교 설계

**Challenge 1**: UI를 어떻게 동적으로 만들 것인가?

**해결**:
```javascript
// 선택지 개수에 따라 동적 생성
function initMultiOptions(count) {
    const container = document.getElementById('multiOptionsContainer');
    container.innerHTML = '';
    
    for (let i = 0; i < count; i++) {
        const card = createOptionCard(i);
        container.appendChild(card);
    }
}
```

**Challenge 2**: API는 어떻게 설계?

**선택지 A**: Request 구조 변경 (breaking change)
```java
class Request {
    Long hourlyWage;
    List<ComparisonOption> options; // 하위 호환 깨짐
}
```

**선택지 B**: 새로운 엔드포인트
```java
POST /api/calculate          // 2안 비교 (기존)
POST /api/calculate/multi    // 다안 비교 (신규)
```

**최종 선택**: B (새 엔드포인트)
**이유**: 기존 2안 비교 코드 영향 없음, 명확한 분리

### Step 4-3: 히스토리 기능

**문제**: 과거 계산을 어떻게 저장하고 재사용할 것인가?

**선택지**:
- A: DB 저장 → 로그인 필요, 복잡
- B: localStorage → 영구 저장, 간단
- C: sessionStorage → 세션 기반, 중간

**1차 선택**: localStorage (v1.0)
**2차 변경**: sessionStorage (v1.3.1)
**변경 이유**: 사용자 피드백 - "서버 재시작 시 이전 기록 혼란"

---

## 5단계: 사용자 테스트 & 피드백 반영 (Day 2, 2시간)

### 문제: "실제로 잘 작동하는가?"

### Step 5-1: 테스트 시나리오 설계

```
[시나리오 1] 기본 사용 흐름
1. 시급 15,000원 입력
2. 선택지 A: 10분, 3,000원
3. 선택지 B: 40분, 2,300원
4. 계산하기 클릭
5. 결과 확인: A 유리 (5,500 vs 12,300)

[시나리오 2] 프리셋 사용
1. "더 싼 마트 vs 가까운 편의점" 클릭
2. 값 자동 입력 확인
3. 계산하기 클릭

[시나리오 3] 다안 비교
1. 다안 비교 모드 선택
2. 3개 선택지 입력
3. 최소 비용 자동 선택 확인

[시나리오 4] 엣지 케이스
1. 시급 0 입력 → 에러 확인
2. 음수 입력 → 에러 확인
3. 동일 비용 → "동일" 표시 확인
```

### Step 5-2: 실제 사용자 피드백

**피드백 1**: "계산식이 이해하기 어렵다"
```
AS-IS: 전체 공식만 표시
TO-BE: 각 선택지별 단계 표시

해결 시간: 1시간
난이도: 중
방법: displayResult() 함수 개선
```

**피드백 2**: "다안 비교 프리셋이 작동하지 않는다"
```
원인 분석:
1. DOM 선택자 문제 → data-index로 해결 시도
2. A/B만 채워짐 → 데이터 구조 문제 발견
3. options 배열로 확장 → 완전 해결

시도 횟수: 3회
총 소요 시간: 2시간
교훈: 데이터 모델 먼저 확정
```

**피드백 3**: "히스토리가 혼란스럽다"
```
문제: localStorage는 영구 저장
해결: sessionStorage로 변경 (10분)
교훈: 간단한 변경도 큰 UX 개선
```

### Step 5-3: 우선순위 재조정

**원래 계획**: 테스트 커버리지 → 배포
**변경 후**: 피드백 반영 → 테스트 → 문서

**이유**: 
- 실제 사용자 문제가 가장 우선
- 배포보다 품질이 중요
- 문서로 "준비 상태" 표현 가능

---

## 6단계: 품질 강화 & 문서화 (Day 2~3, 3시간)

### 문제: "배포 전 뭘 더 확인해야 하나?"

### Step 6-1: 체크리스트 작성

```
[기능]
✅ 2안 비교 작동
✅ 다안 비교 작동
✅ 프리셋 작동
✅ 히스토리 작동
✅ 엣지 케이스 처리

[안정성]
✅ 입력 검증 (프론트+백)
✅ 에러 처리 (전역 핸들러)
✅ 테스트 18개 통과
⚠️ 시급 상한선 → 추가 필요!

[문서]
✅ README (실행 방법)
⚠️ API 문서 → 추가
⚠️ 개선 과정 기록 → CHANGELOG
⚠️ 회고 → RETROSPECTIVE
```

### Step 6-2: 시급 상한선 문제 발견

**발견 경로**:
```
사용자 보고: "10억원 입력 시 에러"
   ↓
로그 확인: "JSON 형식 오류"
   ↓
원인 분석: 상한선 검증 없음
   ↓
해결 방안 설계
```

**해결 과정**:
1. **백엔드 검증 추가**: `@Max(100_000_000)`
2. **프론트엔드 체크 추가**: `if (wage > 100M)`
3. **에러 메시지 개선**: "1억원 이하로 입력"
4. **테스트 추가**: `testExceedsMaxWage()`
5. **문서 업데이트**: 엣지 케이스 10개로 확장

### Step 6-3: 문서 구조화

**문제**: "개선 과정을 어디에 어떻게 기록할 것인가?"

**해결**:
```
README.md          → 문제 정의, 기능, 실행 방법
CHANGELOG.md       → 버전별 변경 이력 (30개 버전)
RETROSPECTIVE.md   → 우선순위 조정, 시간 배분
TROUBLESHOOTING.md → 개별 문제 해결 과정 (17개 항목)
AI_LOG.md          → AI 활용 기록
ARCHITECTURE.md    → 코드 구조 설명
DEPLOYMENT.md      → 배포 가이드
API.md             → API 명세
```

**원칙**: 
- 커밋 메시지는 간략하게
- 상세 내용은 문서로 관리
- 각 문서는 특정 목적에 집중

---

## 전체 과정 요약

### 타임라인

| 시간 | 단계 | 주요 활동 | 산출물 |
|------|------|----------|--------|
| 1h | 1단계 | 문제 정의, MVP 범위 설정 | README 초안 |
| 4h | 2단계 | 계산 로직, DTO, API 구현 | 동작하는 MVP |
| 3h | 3단계 | 검증, 테스트, 예외 처리 | 11개 테스트 |
| 2h | 4단계 | 다안 비교, 히스토리, 캐싱 | 확장 기능 |
| 2h | 5단계 | 사용자 테스트, 피드백 반영 | UX 개선 |
| 3h | 6단계 | 테스트 확장, 문서화 | 18개 테스트, 8개 문서 |

**총 15시간** (실제 작업 시간)

### 핵심 패턴

1. **작은 단위로 분해** → 큰 문제를 작은 문제로
2. **빠른 검증** → MVP로 먼저 확인
3. **반복적 개선** → 피드백 → 수정 → 재검증
4. **문서와 함께** → 왜를 기록
5. **테스트로 보호** → 회귀 방지

### 주요 의사결정

| 결정 | 선택지 A | 선택지 B | 최종 선택 | 이유 |
|------|---------|---------|----------|------|
| 소수점 처리 | round() | floor() | **floor()** | 돈은 버림이 일반적 |
| 캐시 저장소 | Redis | 인메모리 | **인메모리** | MVP 단순성 우선 |
| 히스토리 저장 | localStorage | sessionStorage | **sessionStorage** | 사용자 피드백 |
| 배포 전략 | 실제 배포 | 문서화 | **문서화** | 시간을 품질에 투자 |
| API 설계 | 단일 엔드포인트 | 분리 | **분리** | 하위 호환성 |

---

## 교훈 및 적용

### 성공한 접근

1. **API 우선 전략**
   - 백엔드 먼저 고정 → 프론트 재작업 50% 감소
   
2. **사용자 테스트 조기 진행**
   - 4건 피드백 발견 → 즉시 반영 → 품질 향상

3. **문서 우선 작성**
   - 커밋 전에 CHANGELOG/TROUBLESHOOTING 업데이트
   - 맥락 손실 방지

### 개선할 점

1. **프리셋 데이터 구조**
   - 처음부터 options 배열로 설계했으면 3번 수정 불필요
   
2. **테스트 우선 작성**
   - TDD 방식이었다면 버그 조기 발견
   
3. **시급 상한선 검증**
   - 초기 설계 단계에서 고려했으면 나중에 추가 불필요

### 다음 프로젝트 적용 사항

- [ ] 데이터 모델 먼저, UI는 나중
- [ ] TDD 방식 시도
- [ ] 사용자 테스트를 더 일찍 (MVP 직후)
- [ ] 엣지 케이스 체크리스트 미리 작성
- [ ] 문서 템플릿 준비 (반복 작업 감소)
