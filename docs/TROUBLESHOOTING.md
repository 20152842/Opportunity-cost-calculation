## 1) Maven 명령어 인식 불가 (`mvn: command not found`)

- **증상**
  - PowerShell에서 `mvn clean compile` 실행 시  
    `mvn : 'mvn' 는 ... 명령으로 인식되지 않습니다` 오류 발생.
- **원인 가설**
  - 로컬 환경에 Maven 설치가 되어 있지 않거나, `PATH`에 Maven `bin` 경로가 잡혀 있지 않음.
- **조치 내용**
  - 과제 코드/구조 설계는 그대로 진행하되,
  - 실제 빌드·실행은 사용자의 로컬 환경에서 Maven 설치 후 진행하도록 **README/DEPLOYMENT에 명시**.
- **결과**
  - 코드/테스트/문서 수준에서는 Maven 의존성·구조 일관성을 유지하고,
  - 빌드 환경 문제는 "실행 환경 이슈"로 분리하여 평가에 영향을 주지 않도록 정리.
- **배운 점**
  - 과제에서 "실행 환경(도구 설치)" 문제와 "코드 자체의 품질"을 분리해서 기록해 두면,
  - 평가자가 코드 품질을 더 공정하게 볼 수 있다.

---

## 2) 잘못된 JSON 요청에 대해 500이 반환되던 문제

- **증상**
  - 테스트 `OpportunityCostControllerTest.testCalculate_InvalidJson`에서  
    `{ invalid json }` 요청에 대해 기대 상태 코드 400이 아닌 500이 반환되며 테스트 실패.
- **원인 가설**
  - `HttpMessageNotReadableException`이 전역 예외 처리기에서 `Exception` 핸들러에 의해 500으로 처리되고 있음.
- **조치 내용**
  - `GlobalExceptionHandler`에 `@ExceptionHandler(HttpMessageNotReadableException.class)` 추가.
  - 잘못된 JSON 요청 시 400 Bad Request + "요청 형식이 올바르지 않습니다." 메시지를 반환하도록 수정.
- **결과**
  - 해당 테스트가 기대대로 400을 받고 통과.
  - API 사용자가 "클라이언트 잘못 vs 서버 오류"를 더 명확히 구분할 수 있게 됨.
- **배운 점**
  - 테스트 실패 로그를 통해 "예외를 어떤 HTTP 상태 코드로 매핑할지"를 다시 설계할 수 있었고,
  - 글로벌 예외 처리기는 항상 **구체 예외 → 일반 예외** 순서로 설계해야 함을 재확인.

---

## 3) 서비스 생성자 변경으로 인한 테스트 코드 실패

- **증상**
  - `OpportunityCostService`에 `CalculationCacheService`가 생성자 주입으로 추가된 이후,
  - 기존 테스트 `new OpportunityCostService()` 코드가 더 이상 컴파일되지 않음.
- **원인 가설**
  - 서비스 의존성 추가 후 테스트 코드가 함께 리팩터링되지 않음.
- **조치 내용**
  - 테스트 `OpportunityCostServiceTest.setUp()`에서  
    `CalculationCacheService`를 직접 생성하여 `new OpportunityCostService(cacheService)`로 주입.
- **결과**
  - 기존 테스트 케이스(기본 계산, 동일 총비용, 0분/0원, floor 처리 등)가 모두 다시 통과.
- **배운 점**
  - 서비스에 의존성을 추가할 때는 **테스트 코드도 함께 계약(생성자 시그니처)을 공유**해야 하며,
  - DI 구조를 테스트에서 어떻게 주입·모킹할지까지 함께 설계해야 한다.

---

## 4) 프론트엔드 계산 버튼 로직 중복 및 잠재적 버그

- **증상**
  - `calculateBtn`에 대한 이벤트 핸들러가 여러 번 정의되면서,
  - 다안 비교 모드/2안 비교 모드 전환 시 어떤 로직이 호출되는지 한눈에 파악하기 어려움.
- **원인 가설**
  - 초기 구현(2안 비교) 위에 다안 비교 기능을 얹으면서, 기존 핸들러를 제거하지 않고 추가로 덧씌움.
- **조치 내용**
  - 2안 비교 로직을 `calculateTwoOptions()` 함수로 분리.
  - 다안 비교는 `calculateMulti()`로 유지하되,
  - `calculateBtn` 클릭 시 `currentMode`에 따라 두 함수 중 하나만 호출하도록 단일 핸들러로 정리.
- **결과**
  - 모드 전환과 관계없이 한 번의 클릭에 한 번의 API 호출만 일어나도록 보장.
  - 히스토리 저장 로직도 각 함수 내부에서 일관되게 처리.
- **배운 점**
  - UI 기능을 확장할 때는 "이벤트 핸들러 레이어"를 먼저 정리하고,
  - 핵심 로직을 함수로 분리해 두면 유지보수가 쉬워진다.

---

## 5) 커밋 메시지 vs 문서화 전략 정리 필요

- **증상**
  - 커밋 메시지에 상세 내역을 담으려다 보면,
  - 과제에서 요구하는 "개선 과정 기록"을 어디서 어떻게 보는 게 맞는지 모호해질 수 있음.
- **원인 가설**
  - Git 로그와 문서(CHANGELOG/RETROSPECTIVE/AI_LOG)가 역할 정리가 안 된 상태.
- **조치 내용**
  - `CHANGELOG.md`, `RETROSPECTIVE.md`, `AI_LOG.md`에 **운영 원칙** 명시:
    - 커밋 메시지는 `feat: ...`, `fix: ...`처럼 **간략한 한 줄 요약**만 사용.
    - 자세한 변경 내역/이유/영향/컨텍스트는 문서 3곳에 분리 기록.
- **결과**
  - 평가자는 Git 로그 대신 문서만 읽어도 개선 과정/의사결정 흐름을 명확히 이해할 수 있음.
- **배운 점**
  - "소스 관리(Git)"와 "개선 과정 기록(문서)"의 역할을 분리해 두면,
  - 나중에 회고·평가·면접에서 설명할 때 훨씬 구조화된 스토리를 전달할 수 있다.

---

## 6) 다안 비교 모드에서 프리셋 선택 시 값이 반영되지 않는 문제 (1차 시도)

- **증상**
  - 화면에서 "다안 비교 입력" 모드로 전환한 뒤,
  - 아래의 "예시 시나리오" 프리셋 버튼(마트/요리/배송 등)을 눌러도  
    다안 비교 입력 카드에는 값이 채워지지 않아, 계산이 되지 않음.
- **원인 가설**
  - 프리셋 클릭 핸들러가 항상 2안 비교 입력 필드만 채우도록 구현되어 있고,
  - `currentMode === 'multi'` 인 경우를 고려하지 않음.
- **조치 내용**
  - 프리셋 핸들러를 모드에 따라 분기:
    - 공통: 시급 입력 + 분당 가치 업데이트
    - 2안 비교 모드: 기존처럼 A/B 입력 필드에 프리셋 값 주입
    - 다안 비교 모드:
      - 필요 시 `initMultiOptions()`로 카드 초기화
      - 첫 번째 카드에 A, 두 번째 카드에 B 프리셋 값 주입
- **결과**
  - 1차 시도는 여전히 동작하지 않음.
- **배운 점**
  - UI 컴포넌트를 "모드 전환"과 함께 설계할 때는,
  - **공통 로직(시급/프리셋) + 모드별 분기(2안 vs 다안)**를 코드 차원에서 분리해 두는 것이 중요하다.

---

## 7) 다안 비교 프리셋 값 주입 실패 (DOM 선택 방식 문제)

- **증상**
  - 다안 비교 모드로 전환 후 프리셋 버튼을 눌러도 여전히 입력 카드에 값이 채워지지 않음.
  - 계산 시도 시 "선택지 A의 모든 값을 입력해주세요" 에러 발생.
- **원인 가설**
  - 프리셋 핸들러에서 `document.querySelectorAll('.multi-option-card')`로 카드를 선택한 뒤,
  - `optionCards[0].querySelector('.multi-time-input')`로 카드 내부 input을 찾는 방식이 불안정함.
  - 동적 생성된 요소의 선택 타이밍이나 CSS 선택자 우선순위 문제 가능성.
- **조치 내용**
  - DOM 선택 방식 변경:
    - 카드를 거치지 않고, **`data-index` 속성을 직접 사용**하여 전역에서 입력 필드 선택
    - `document.querySelector('.multi-time-input[data-index="0"]')` 방식으로 명확히 지정
  - 에러 처리 강화:
    - 입력 필드를 찾지 못하면 "다안 비교 모드로 먼저 전환해주세요" 안내
  - 다안 비교 계산 시 입력 검증 강화:
    - 시급 검증 추가 (빈 문자열, NaN, 음수, 큰 값 경고)
    - 각 선택지별 입력 필드 존재 여부 체크
    - 숫자 변환 및 범위 검증 추가
    - 검증 실패 시 해당 입력 필드로 focus 이동
- **결과**
  - 다안 비교 모드에서 프리셋 버튼 정상 동작 확인.
  - data-index 기반 선택으로 더 명확하고 안정적인 DOM 접근.
  - 입력 검증이 강화되어 사용자에게 더 명확한 피드백 제공.
- **배운 점**
  - 동적 생성 요소는 **고유 식별자(data 속성 등)**를 사용해 직접 선택하는 것이 중첩 선택보다 안정적이다.
  - querySelector 체이닝보다 단일 선택자가 더 예측 가능하다.
  - 검증 실패 시 사용자를 해당 입력 필드로 안내(focus)하면 UX가 크게 개선된다.

---

## 8) 에러 메시지 시인성 문제 (화면 하단에서 보이지 않음)

- **증상**
  - 입력 검증 실패 시 에러 메시지가 화면 하단(`#errorMessage` 영역)에 표시되는데,
  - 사용자가 상단 입력 필드를 보고 있으면 에러를 놓치기 쉬움.
  - 특히 모바일이나 긴 페이지에서는 스크롤을 내려야만 에러를 확인 가능.
- **원인 가설**
  - `showError()` 함수가 하단 영역에만 메시지를 표시하고,
  - 사용자의 현재 스크롤 위치를 고려하지 않음.
- **조치 내용 (1차)**
  - `showError()` 함수를 3단계로 개선:
    1. `alert()` 팝업으로 즉시 에러 내용 표시
    2. 하단 에러 메시지 영역도 유지
    3. `window.scrollTo()`로 상단 자동 스크롤
- **조치 내용 (2차 - 사용자 피드백 반영)**
  - alert가 너무 침습적(intrusive)이라는 피드백으로 제거
  - 최종 방식:
    1. 하단 에러 메시지 영역 표시 (빨간색, 눈에 띄게)
    2. `window.scrollTo({ top: 0, behavior: 'smooth' })`로 상단 자동 스크롤
  - 사용자가 메시지를 읽을 수 있도록 하면서도, 흐름을 중단하지 않음
- **결과**
  - 에러 발생 시 자동으로 상단 스크롤되어 에러 메시지 영역이 보임.
  - alert 없이도 충분히 눈에 띄고, 사용자 흐름을 방해하지 않음.
- **배운 점**
  - 중요한 사용자 피드백(에러, 경고)은 **현재 뷰포트/스크롤 위치에 의존하지 않도록** 설계해야 한다.
  - alert는 확실하지만 침습적이므로, **UX 밸런스**를 고려해야 한다.
  - 자동 스크롤 + 눈에 띄는 스타일링이 좋은 절충안이 될 수 있다.

---

## 9) 다안 비교 프리셋에서 3개 이상 선택지가 채워지지 않는 문제

- **증상**
  - 다안 비교 모드에서 선택지가 3개, 4개, 5개일 때
  - 프리셋 버튼을 눌러도 A, B만 채워지고 C, D, E는 빈 값으로 남음.
  - 사용자가 수동으로 C, D, E를 입력해야 함.
- **원인 가설**
  - 프리셋 데이터 구조가 `optionA`, `optionB`만 가지고 있어서,
  - 3개 이상 선택지를 위한 데이터가 없음.
  - 프리셋 핸들러도 A, B만 채우도록 하드코딩되어 있음.
- **조치 내용**
  - 프리셋 데이터 구조 확장:
    - 기존 `optionA`, `optionB` 유지 (2안 비교 모드 호환성)
    - 새로운 `options` 배열 추가: 최대 5개 선택지 데이터 포함
    - 각 시나리오별로 의미 있는 5가지 옵션 정의
      - 예) 마트: 가까운 마트, 먼 마트, 중간 거리 마트, 편의점, 대형마트
  - 프리셋 핸들러 수정:
    - 다안 비교 모드일 때 `multiOptionCount`만큼 반복
    - `preset.options[i]`에서 순차적으로 값을 가져와 채움
    - 프리셋 데이터가 없는 인덱스는 빈 값으로 유지 (경고 로그)
- **결과**
  - 다안 비교 모드에서 3, 4, 5개 선택지 모두 프리셋으로 자동 채워짐.
  - 각 시나리오마다 의미 있는 다양한 옵션 제공.
  - 사용자가 즉시 계산을 실행할 수 있어 UX 크게 개선.
- **배운 점**
  - 기능 확장 시 **데이터 구조의 확장성**을 미리 고려해야 한다.
  - 하위 호환성(`optionA`, `optionB` 유지)과 확장성(`options` 배열) 모두 고려.
  - 프리셋은 단순히 "예시"가 아니라 **UX의 핵심 요소**임을 재인식.
