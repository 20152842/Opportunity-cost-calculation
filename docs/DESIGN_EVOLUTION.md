# 설계 진화 과정 (Design Evolution)

## 목적
이 문서는 **처음 설계와 최종 결과물 사이의 변경 사항**을 명확히 기록하여, 프로젝트가 어떻게 진화했는지 투명하게 보여줍니다.

---

## 1. 초기 설계 (v0.1 ~ v0.2)

### 핵심 아이디어
"사람들은 시간의 가치를 과소평가한다. 시급을 기준으로 시간을 돈으로 환산하여, 선택지를 총비용으로 비교하는 계산기를 만들자."

### 초기 기능 범위
```
[필수 MVP]
- 시급 입력
- 선택지 A/B 입력 (시간, 비용)
- 총비용 계산 (직접비용 + 시간비용)
- 추천 결과 표시

[고려 중]
- 프리셋 예시?
- 계산 근거 표시?
- 엣지 케이스 처리?
```

### 초기 기술 스택 계획
- **Backend**: Java + Spring Boot (확정)
- **Frontend**: Thymeleaf + 간단한 CSS
- **DB**: 없음 (상태 비저장)
- **배포**: 시간 있으면

### 초기 데이터 모델
```java
// 매우 단순한 구조
class Request {
    long hourlyWage;
    int timeA, timeB;
    long costA, costB;
}

class Response {
    long totalCostA, totalCostB;
    String recommendation;
}
```

---

## 2. 중간 설계 변경 (v0.3 ~ v0.9)

### 변경 1: 근거 제공 기능 추가 (v0.4)
**결정 시점**: MVP 구현 중
**변경 내용**: Response에 `breakdown` (직접비용/시간비용 분해) 추가
**이유**: 
- 사용자가 "왜 이 결과인지" 이해하지 못하면 신뢰하지 않음
- 계산 과정을 보여주는 것이 투명성과 신뢰도 향상에 핵심

**Before**:
```json
{
  "recommendation": "A",
  "totalCostA": 5500,
  "totalCostB": 12300
}
```

**After**:
```json
{
  "optionA": {
    "directCost": 3000,
    "timeCost": 2500,
    "totalCost": 5500
  },
  "optionB": {
    "directCost": 2300,
    "timeCost": 10000,
    "totalCost": 12300
  },
  "recommendation": "A",
  "costDifference": 6800,
  "formula": "총 비용 = 직접 비용 + (시급 ÷ 60) × 소요 시간(분)"
}
```

### 변경 2: 프리셋 예시 추가 (v0.5)
**결정 시점**: 기본 UI 완성 후
**변경 내용**: 실제 시나리오 기반 프리셋 6개 추가
**이유**:
- 사용자가 빈 입력 폼을 보고 "뭘 입력해야 하지?" 고민
- 구체적 예시가 있으면 즉시 이해 가능

**초기 계획**: 프리셋 없이 placeholder만
**최종 구현**: 
- "더 싼 마트 vs 가까운 편의점"
- "직접 요리 vs 배달"
- "택시 vs 대중교통 + 도보"
- 각 프리셋 클릭 시 자동 입력

### 변경 3: 다안 비교 기능 추가 (v0.9)
**결정 시점**: MVP 안정화 후
**변경 내용**: 2개 고정 → 3~5개 동적 선택
**이유**:
- 실제 의사결정은 3개 이상 비교하는 경우가 많음
- "확장 가능성"을 보여주기 위해

**Before**:
```
선택지 A [고정]
선택지 B [고정]
```

**After**:
```
선택지 개수 선택 (3/4/5)
[선택지 추가] [선택지 제거]
선택지 1, 2, 3, 4, 5 (동적)
→ 최소 비용 자동 선택
```

---

## 3. 사용자 피드백 기반 재설계 (v1.1 ~ v1.3)

### 실제 사용자 테스트 결과 (2026-02-12)

#### 피드백 1: "계산식이 이해하기 어렵다"
**문제**: 전체 계산식만 있고, 각 선택지별 분해가 없음
**해결**:
```javascript
// Before (v0.5)
formula: "총 비용 = 직접 비용 + (시급 ÷ 60) × 소요 시간(분)"

// After (v1.3.0)
📊 계산 공식: 총 비용 = 직접 비용 + (시급 ÷ 60) × 소요 시간(분)
분당 가치 = 15,000원/시간 ÷ 60 = 250원/분

【선택지 A 상세 계산】
・직접 비용: 3,000원
・시간 비용: 250원/분 × 10분 = 2,500원
・총 비용: 3,000원 + 2,500원 = 5,500원

【선택지 B 상세 계산】
・직접 비용: 2,300원
・시간 비용: 250원/분 × 40분 = 10,000원
・총 비용: 2,300원 + 10,000원 = 12,300원

✅ 결론: 선택지 A이(가) 6,800원 더 유리합니다
```

#### 피드백 2: "히스토리가 서버 재시작 후에도 남아있어 혼란스럽다"
**문제**: localStorage는 영구 저장
**Before**: `localStorage` (브라우저 닫아도 유지)
**After**: `sessionStorage` (탭 닫으면 삭제)
**이유**: 새 세션마다 깨끗한 시작이 사용자 경험에 더 적합

#### 피드백 3: "다안 비교에서 프리셋이 작동하지 않는다"
**문제**: 프리셋 데이터 구조가 2개만 지원
**Before**:
```javascript
presets: {
  mart: { optionA: {...}, optionB: {...} }
}
```

**After**:
```javascript
presets: {
  mart: {
    optionA: {...}, optionB: {...}, // 하위 호환
    options: [{...}, {...}, {...}, {...}, {...}] // 확장
  }
}
```

**해결 시도**:
1. 1차: data-index로 A/B만 채움 → C/D/E 비어있음
2. 2차: 반복문으로 options 배열 순회 → 완전 해결
3. 결과: 3~5개 선택지 모두 자동 채움

#### 피드백 4: "1시간 20분을 분으로 어떻게 변환하지?"
**문제**: 단위 혼동
**Before**: placeholder만 ("예: 80")
**After**: 접기/펴기 가능한 변환 가이드
```html
<details>
  <summary>💡 시간 단위 변환 도움</summary>
  <ul>
    <li>1시간 = 60분</li>
    <li>1시간 30분 = 90분</li>
    <li>2시간 = 120분</li>
  </ul>
</details>
```

---

## 4. 품질 강화 단계 (v1.4 ~ v1.8)

### 변경 4: 테스트 커버리지 확장
**이유**: 실제 사용자 테스트에서 버그 발견 경험
**Before**: 11개 테스트 (기본 케이스만)
**After**: 18개 테스트

**추가된 테스트**:
- 매우 큰 시급 (200만원)
- 매우 긴 시간 (500분)
- 캐시 동작 검증
- 음수 시간
- 음수 비용
- 잘못된 JSON
- 시급 0원
- **시급 상한선 초과 (2억원)**

### 변경 5: 엣지 케이스 추가 - 시급 상한선
**결정 시점**: 사용자가 "10억원" 입력 시 에러 보고
**문제**: "요청 형식이 올바르지 않습니다. JSON 형식을 다시 확인해주세요."
**이유**: JavaScript Number 안전 범위 초과

**Before**: 검증 없음
**After**: 
- 백엔드: `@Max(value = 100_000_000)` // 1억원
- 프론트엔드: `if (hourlyWage > 100000000)` 체크
- 에러 메시지: "시급은 1억원 이하로 입력해주세요."

---

## 5. 최종 설계 (v1.8.0)

### 최종 아키텍처

```
┌─────────────────────────────────────────┐
│          Frontend (Thymeleaf)           │
│  - 2안/다안 모드 전환                    │
│  - 프리셋 자동 입력 (최대 5개)           │
│  - 상세 계산식 표시                      │
│  - sessionStorage 히스토리               │
│  - 접기/펴기 단위 변환 가이드            │
└─────────────────────────────────────────┘
                    ↕ REST API
┌─────────────────────────────────────────┐
│   Controller (입력 검증 + 에러 처리)     │
│  - @Valid, @NotNull, @Min, @Max        │
│  - GlobalExceptionHandler               │
└─────────────────────────────────────────┘
                    ↕
┌─────────────────────────────────────────┐
│      Service (계산 로직 + 캐싱)          │
│  - floor() 소수점 처리                   │
│  - CacheService (TTL 1시간)             │
│  - 로깅 (시급 경고)                      │
└─────────────────────────────────────────┘
                    ↕
┌─────────────────────────────────────────┐
│              DTO/Model                  │
│  - CalculationRequest (검증 포함)       │
│  - CalculationResponse (breakdown)      │
│  - ComparisonOption                     │
└─────────────────────────────────────────┘
```

### 최종 데이터 모델

```java
@Data
public class CalculationRequest {
    @NotNull(message = "시급은 필수 입력 항목입니다.")
    @Min(value = 1, message = "시급은 1원 이상이어야 합니다.")
    @Max(value = 100_000_000, message = "시급은 1억원 이하로 입력해주세요.")
    private Long hourlyWage;
    
    @NotNull @Valid
    private ComparisonOption optionA;
    
    @NotNull @Valid
    private ComparisonOption optionB;
}

@Data
public class ComparisonOption {
    @Min(value = 0, message = "소요 시간은 0분 이상이어야 합니다.")
    private Integer timeMinutes;
    
    @Min(value = 0, message = "직접 비용은 0원 이상이어야 합니다.")
    private Long directCost;
}

@Data
public class CalculationResponse {
    private OptionBreakdown optionA;
    private OptionBreakdown optionB;
    private String recommendation; // "A", "B", "동일"
    private Long costDifference;
    private String formula; // 상세 계산식
}
```

---

## 6. Before / After 총정리

| 항목 | 초기 설계 (v0.1) | 최종 결과 (v1.8.0) | 변경 이유 |
|------|-----------------|-------------------|----------|
| **기능 범위** | 2안 비교만 | 2안 + 다안(3~5개) | 실제 사용 시나리오 반영 |
| **입력 검증** | 프론트엔드만 | 프론트+백엔드 이중 검증 | 안정성 강화 |
| **에러 메시지** | 일반적 메시지 | 구체적 상황별 메시지 | 사용자 경험 |
| **계산 근거** | 총비용만 | 분해 + 단계별 계산식 | 신뢰도 향상 |
| **프리셋** | 없음 | 6개 시나리오 × 5개 옵션 | 온보딩 |
| **히스토리** | 없음 → localStorage | sessionStorage | 사용자 피드백 |
| **캐싱** | 없음 | 인메모리 (TTL 1시간) | 성능 최적화 |
| **테스트** | 없음 | 18개 | 품질 보증 |
| **문서** | README만 | 9개 문서 | 맥락 관리 |
| **엣지 케이스** | 3개 | 10개 | 안정성 |

---

## 7. 결정하지 않은 것들 (Trade-offs)

### 결정 A: 인메모리 캐시 vs Redis
- **선택**: 인메모리
- **이유**: MVP 단계에서는 단순성 우선, 확장은 필요시 진행
- **Trade-off**: 단일 인스턴스 한정, 재시작 시 캐시 손실
- **향후**: Redis로 교체 가능 (CacheService 인터페이스화)

### 결정 B: 배포 vs 로컬 완성도
- **선택**: 로컬 완성도 + 배포 문서화
- **이유**: 실제 배포 URL보다 기능 정확성이 평가에서 더 중요
- **Trade-off**: 접근성은 떨어지지만, 시간을 품질에 투자
- **향후**: Docker 이미지 준비 완료, 배포는 10분 내 가능

### 결정 C: Thymeleaf vs React
- **선택**: Thymeleaf
- **이유**: Spring Boot와 통합 쉬움, SSR로 초기 로딩 빠름
- **Trade-off**: 동적 UI 구현 시 Vanilla JS 필요
- **향후**: API가 이미 분리되어 있어 React로 전환 용이

### 결정 D: floor() vs round()
- **선택**: floor()
- **이유**: 돈은 버림 처리가 일반적, 과대 평가 방지
- **Trade-off**: 매우 작은 차이가 무시될 수 있음
- **정당화**: 실무에서도 원 단위 절사가 표준

---

## 8. 주요 교훈

### 교훈 1: 사용자 피드백의 가치
**배움**: 문서나 테스트로는 발견할 수 없는 실제 사용성 문제 발견
**예시**: 히스토리 정책, 단위 변환 가이드, 계산식 상세화
**적용**: 조기 사용자 테스트 → 즉시 반영

### 교훈 2: 데이터 모델 먼저, UI는 나중
**배움**: API 스펙이 바뀔 때마다 UI를 두 번씩 수정하는 비효율 경험
**예시**: 다안 비교 프리셋 3차 수정
**적용**: 데이터 구조 확정 → UI 구현 순서 고수

### 교훈 3: 문서는 코드만큼 중요
**배움**: 커밋 메시지만으로는 "왜"를 설명할 수 없음
**예시**: CHANGELOG, RETROSPECTIVE, TROUBLESHOOTING 분리
**적용**: 문서 우선 작성 → 코드 구현

### 교훈 4: 완벽보다 완성
**배움**: 배포까지 완료하려다 기능 품질이 떨어질 뻔함
**예시**: 배포 문서화로 대체, 시간을 테스트/피드백에 투자
**적용**: 핵심에 집중, 부가 기능은 문서화로 준비 상태 유지

---

## 9. 다음 진화 방향

### 단기 (v2.0)
- [ ] 로그인/사용자 관리
- [ ] 서버 기반 히스토리 (영구 저장)
- [ ] 계산 히스토리 통계 (가장 많이 비교한 항목)

### 중기 (v3.0)
- [ ] Redis 캐시 도입 (수평 확장)
- [ ] React 프론트엔드 (SPA)
- [ ] 모바일 앱 (React Native)

### 장기 (v4.0)
- [ ] AI 기반 인사이트 ("당신의 시간 가치는 상위 10%입니다")
- [ ] 소셜 공유 ("내 선택을 친구에게 물어보기")
- [ ] A/B 테스트 (프리셋 최적화)
